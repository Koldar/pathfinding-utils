#ifndef _PATHFINDING_UTILS_ISOLUTION_PATH_HEADER__
#define _PATHFINDING_UTILS_ISOLUTION_PATH_HEADER__

#include <cpp-utils/vectorplus.hpp>
#include <cpp-utils/igraph.hpp>
#include <cpp-utils/commons.hpp>
#include <cpp-utils/math.hpp>

#include "types.hpp"
#include "operators.hpp"
#include "IPath.hpp"

namespace pathfinding::search {

    using namespace pathfinding;
    using namespace cpp_utils::graphs;

    /**
     * @brief a sequence which represents the solution path generated by A*
     * 
     * This class is pretty similar to a vectorplus, but it has fewer features.
     * 
     * @tparam STATE base type of the state (no pointers ,nothing)
     * @tparam IN_VECTOR a ISolutionPath is a vector. This type represents what is put inside the vector. By default is `const STATE*`
     * @tparam CONST_REF a constant reference of STATE. By default it's `const STATE&`
     */
    //TODO should be called AbstractSolutionPath
    template <typename STATE, typename IN_VECTOR=const STATE*, typename STATE_CONST_REF=const STATE&>
    class ISolutionPath {
        using This = ISolutionPath<STATE, IN_VECTOR, STATE_CONST_REF>;
    protected:
        cpp_utils::vectorplus<IN_VECTOR> path;
    public:
        ISolutionPath(): path{} {

        }
        ISolutionPath(const vectorplus<IN_VECTOR>& path): path{path} {

        }
        virtual ~ISolutionPath() {

        }
        ISolutionPath(const This& o): path{o.path} {

        }
        ISolutionPath(This&& o): path{o.path} {
            o.path.cleanup();
        }
        This& operator = (const This& o) {
            this->path = o.path;
            return *this;
        }
        This& operator = (This&& o) {
            this->path = std::move(o.path);
            return *this;
        }
    public:
        virtual size_t size() const {
            return this->path.size();
        }
        virtual int lastIndex() const {
            return this->path.lastIndex();
        }
        void add() {

        }
        template <typename... OTHER>
        void add(STATE_CONST_REF s, OTHER... others) {
            this->path.add(s);
            this->path.add(others...);
        }
        typename cpp_utils::vectorplus<IN_VECTOR>::iterator begin() const {
           return this->path.begin(); 
        }
        typename cpp_utils::vectorplus<IN_VECTOR>::iterator end() const {
           return this->path.end(); 
        }
    public:
        virtual void addHead(STATE_CONST_REF s) = 0;
        /**
         * @brief Get the solution cost
         * 
         * @return cost_t 
         */
        virtual cost_t getCost() const = 0;
        virtual void add(STATE_CONST_REF s) = 0;
        virtual STATE_CONST_REF at(int index) const = 0;
    public:
        STATE_CONST_REF operator[](int index) const {
            return this->at(index);
        }
        virtual STATE_CONST_REF getStart() const {
            return this->at(0);
        }
        virtual STATE_CONST_REF getGoal() const {
            return this->at(-1);
        }
    public:
        //TODO should be in their own files
        template <typename OUT>
        vectorplus<OUT> map(const function_t<STATE_CONST_REF, OUT>& mapper) const {
            vectorplus<OUT> result{};
            for (int i=0; i<this->path.size(); ++i) {
                result.add(mapper(this->at(i)));
            }
            return result;
        }

        /**
         * @brief left reduce operation
         * 
         * @code
         * vector={1,2,3,4};
         * first=0;
         * lambda=+
         * (((((0) + 1) + 2) + 3) + 4)
         * @endcode
         * 
         * @tparam OUT the type of the result of this operation
         * @param first first value used to combine to the head of the vector
         * @param lambda function to apply
         * @return OUT value obtained by the reduction
         */
        template <typename OUT>
        OUT lreduce(const OUT& first, const bifunction_t<STATE_CONST_REF, OUT, OUT>& lambda) const {
            OUT result{first};
            for (int i=0; i<this->path.size(); ++i) {
                result = lambda(this->at(i), result);
            }
            return result;
        }

        /**
         * @brief right reduce operation
         * 
         * @code
         * vector={1,2,3,4};
         * first=0;
         * lambda=+
         * (1 + (2 + (3 + (4 + (0)))))
         * @endcode
         * 
         * @tparam OUT the type of the result of this operation
         * @param first first value used to combine to the tail of the vector
         * @param lambda function to apply
         * @return OUT value obtained by the reduction
         */
        template <typename OUT>
        OUT rreduce(const OUT& first, const bifunction_t<STATE_CONST_REF, OUT, OUT>& lambda) const {
            OUT result{first};
            for (int i=this->lastIndex(); i>=0; --i) {
                result = lambda(this->at(i), result);
            }
            return result;
        }
        friend std::ostream& operator <<(std::ostream& out, const This& a) {
            return out << a.path;
        }
    };

    /**
     * @brief A solution which contain search algorithm A* like states
     * 
     * This solution contains only pointers of the actual states
     * 
     * @tparam STATE the type of state inside this solution
     * @tparam CONST_REF constant reference of STATE
     */
    template <typename STATE>
    class StateSolutionPath: public ISolutionPath<STATE, const STATE*, const STATE&> {
    public:
        using This = StateSolutionPath<STATE>;
        using Super = ISolutionPath<STATE, const STATE*, const STATE&>;
        using Super::map;
        using Super::add;
        using Super::addHead;
    public:
        virtual void addHead(const STATE& s) {
            this->path.addHead(&s);
        }
        virtual const STATE& at(int index) const {
            return *this->path.at(index);
        }
        virtual void add(const STATE& s) {
            this->path.add(&s);
        }
        virtual cost_t getCost() const {
            return this->getGoal().getCost();
        }
    };

    /**
     * @brief A solution which is a sequence of vertices inside a graph
     * 
     * @tparam G payload of the whole graph
     * @tparam V payload of an vertex
     * @tparam E paylaod type of each edge
     */
    template <typename G, typename V, typename E>
    class GraphSolutionPath: public ISolutionPath<nodeid_t, nodeid_t, nodeid_t> {
    public:
        using This = GraphSolutionPath<G,V,E>;
        using Super = ISolutionPath<nodeid_t, nodeid_t, nodeid_t>;
        using Super::add;
    private:
        const cpp_utils::graphs::IImmutableGraph<G, V, E>& g;
        const cpp_utils::function_t<E, cost_t> costFunction;
    public:
        GraphSolutionPath(const cpp_utils::graphs::IImmutableGraph<G, V, E>& g, cpp_utils::function_t<E, cost_t> costFunction): g{g}, costFunction{costFunction} {

        }
    public:
        virtual void addHead(nodeid_t s) {
            this->path.addHead(s);
        }
        virtual nodeid_t at(int index) const {
            return this->path.at(index);
        }
        virtual void add(nodeid_t s) {
            this->path.add(s);
        }
        virtual cost_t getCost() const {
            if (this->size() <= 1) {
                return 0;
            }
            cost_t result = 0;
            for (int i=1; i<this->size(); ++i) {
                result += this->costFunction(g.getEdge((*this)[i-1], (*this)[i]));
            }
            return result;
        }
    };

}

#endif