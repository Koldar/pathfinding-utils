/**
 * @file
 * @author Massimo Bono
 * @brief a state which is based upon a graph but doesn't directly reference it. Use it if you don't care to access to the underlying graph
 * @version 0.1
 * @date 2019-10-7
 * 
 * @copyright Copyright (c) 2019
 * 
 */
#ifndef _PATH_FINDING_UTILS_ABSTRACT_GRAPH_STATE_HEADER__
#define _PATH_FINDING_UTILS_ABSTRACT_GRAPH_STATE_HEADER__

#include "ISearchState.hpp"
#include "IStateSupplier.hpp"
#include "IStateExpander.hpp"
#include "IGoalChecker.hpp"
#include <cpp-utils/StaticPriorityQueue.hpp>
#include <cpp-utils/igraph.hpp>
#include <cpp-utils/mapplus.hpp>
#include <cpp-utils/vectorplus.hpp>
#include <cpp-utils/adjacentGraph.hpp>
#include <tuple>

namespace pathfinding::search {

    using namespace pathfinding;
    using namespace cpp_utils::graphs;

    /**
     * @brief A* state where a state is identified by a location nodeid_t 
     * 
     * The state represents a position in the graph. However, the graph is **not** referenced explicitly in the state.
     * This is a lightweight representation of the state.
     * 
     * This state contains the value of the vertex payload it intend to represents
     * 
     * @tparam REASON  a type represeting how this state has been generated. Could be an integer that, if it is 1, it has been generated by the user (e.g., start goal) or 2, if the state has been generated during a search. This value can be used in several fields, like logging. Usually it is good to create a enumeration for it
     */
    template <typename REASON, typename... IMPORTANT_STUFF>
    class AbstractGraphState: public IAstarState<REASON>, cpp_utils::HasPriority<priority_t> {
        using This =  AbstractGraphState<REASON, IMPORTANT_STUFF...>;
        using Super1 = IAstarState<REASON>;
    protected:
        /**
         * @brief f value in A*
         * 
         */
        cost_t f;
        /**
         * @brief g value in A*
         * 
         */
        cost_t g;
        /**
         * @brief h value in A*
         * 
         */
        cost_t h;
        /**
         * @brief parent of state. If null the state do not have any parent
         * 
         * @note
         * this pointer should point to a state which has the same type
         */
        void* parent;
        /**
         * @brief id uniquely identifying tyhe state
         * 
         */
        stateid_t id;
        /**
         * @brief if true it means this state should belong to the close list of A*
         * 
         */
        bool expanded;
        /**
         * @brief field necessary if you want to put this instance in a queue
         * 
         */
        priority_t priority;
        /**
         * @brief a structure containing where we are in the graph representing the map
         * 
         */
        nodeid_t position;
        /**
         * @brief a value representing how this state has been created
         * 
         */
        REASON reason;
    public:
        AbstractGraphState(cost_t f, cost_t g, cost_t h, const This* parent, stateid_t id, bool expanded, nodeid_t position, const REASON& reason): f{f}, g{g}, h{h}, parent{static_cast<void*>(parent)}, id{id}, expanded{expanded}, position{position}, priority{0}, reason{reason} {

        }

        AbstractGraphState(stateid_t id, nodeid_t position, const REASON& reason): f{0}, g{0}, h{0}, parent{nullptr}, id{id}, expanded{false}, position{position}, priority{0}, reason{reason} {

        }

        /**
         * @brief Create a state with the default reason. Useful because the reason in tests are rarely important
         * 
         * @param id the id of the state to generate
         * @param position the position where the state is in the A* graph
         */
        AbstractGraphState(stateid_t id, nodeid_t position): f{0}, g{0}, h{0}, parent{nullptr}, id{id}, expanded{false}, position{position}, priority{0}, reason{REASON::getFirst()} {

        }

        AbstractGraphState(const This& other): f{other.f}, g{other.g}, h{other.h}, parent{other.parent}, id{other.id}, expanded{other.expanded}, position{other.position}, priority{other.priority}, reason{other.reason} {
        }
        This& operator =(const This& other) {
            this->f = other.f;
            this->g = other.g;
            this->h = other.h;
            this->parent = other.parent;
            this->id = other.id;
            this->expanded = other.expanded;
            this->position = other.position;
            this->priority = other.priority;
            this->reason = other.reason;
            return *this;
        }
        AbstractGraphState(This&& other): f{other.f}, g{other.g}, h{other.h}, parent{other.parent}, id{other.id}, expanded{other.expanded}, position{other.position}, priority{other.priority}, reason{std::move(other.reason)} {
        }
        This& operator =(This&& other) {
            this->f = other.f;
            this->g = other.g;
            this->h = other.h;
            this->parent = other.parent;
            this->id = other.id;
            this->expanded = other.expanded;
            this->position = other.position;
            this->priority = other.priority;
            this->reason = std::move(other.reason);
            return *this;
        }
        
        nodeid_t getPosition() const {
            return this->position;
        }

        REASON getReason() const {
            return this->reason;
        }

        virtual std::tuple<const IMPORTANT_STUFF&...> getPayload() const = 0;
    public:
        friend bool operator <(const This& a, const This& b) {
            if(a.f < b.f) {
                return true;
            } else if (b.f < a.f) {
                return false;
            }
            //ok, it appeans that a and b have the same f. We need some tie breaking mechanism
            // break ties in favour of larger g
            if(a.g > b.g) {
                return true;
            }
            return false;
        }
        friend bool operator ==(const This& a, const This& b) {
            if (&a == &b) {
                return true;
            }
            if (a.getId() != b.getId()) {
                return false;
            }
            return a.getPosition() == b.getPosition();
        }
        friend std::ostream& operator <<(std::ostream& out, const This& state) {
            out 
                << "{id: " 
                << state.getId() 
                << " node: " 
                << state.getPayload()
                << "}";
            return out;
        }
    public:
        priority_t getPriority(const void* q) const {
            return this->priority;
        }
        void setPriority(const void* q, priority_t p) {
            this->priority = p;
        }
    public:
        virtual void setF(cost_t f) {
            this->f = f;
        }
        virtual void setG(cost_t g) {
            this->g = g;
        }
        virtual void setH(cost_t h) {
            this->h = h;
        }
        virtual void setParent(ISearchState<REASON>* parent) {
            this->parent = parent;
        }
        virtual void setId(stateid_t id) {
            this->id = id;
        }
        virtual void setExpanded(bool expanded) {
            this->expanded = expanded;
        }
        virtual cost_t getF() const {
            return this->f;
        }
        virtual cost_t getG() const {
            return this->g;
        }
        virtual cost_t getH() const {
            return this->h;
        }
        virtual This* getParent() {
            return static_cast<This*>(this->parent);
        }
        virtual const This* getParent() const {
            return static_cast<const This*>(this->parent);
        }
        virtual stateid_t getId() const {
        return this->id;
        }
        virtual bool isExpanded() const {
            return this->expanded;
        }
    public:
        MemoryConsumption getByteMemoryOccupied() const {
            return sizeof(*this);
        }
    };

}


#endif